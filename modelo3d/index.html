<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>3dCupcake</title>
	<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	<script src="js/lib/three.js"></script>
	<script src="js/lib/jquery.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/Projector.js"></script>
	<script src="js/Stats.js"></script>
	<script src="js/OrbitControls.js"></script>

</head>
<body>

	<div id="WebGL-salida"></div>

	<script type="text/javascript">
	var container, escena, camara, renderer, controls, stats;
	var projector, mouse = { x: 0, y: 0 };
	var targetList = [];
	var cubo;
	
	$(function(){
		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		escena = new THREE.Scene();
		camara = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
		
		// rederizador con la aceleradora
		renderer = new THREE.WebGLRenderer();
		
		//renderer.setClearColorHex(0xEEEEEE);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMap.enabled = true;
		
		var ejes = new THREE.AxisHelper(20);
		//escena.add(ejes);
		
		var planoGeometria = new THREE.PlaneGeometry(60,20);
		var materialPlano = new THREE.MeshLambertMaterial({
			color: 0xcccccc
		});
		var plano = new THREE.Mesh(planoGeometria, materialPlano);
		
		// el plano recibe sombra
		plano.receiveShadow = true;
		plano.castShadow = false;
		
		plano.rotation.x=-0.5*Math.PI;
		plano.position.x = 15;
		plano.position.y = 0;
		plano.position.z = 0;
		
		
		escena.add(plano);
		
		
		var geometriaCubo = new THREE.CubeGeometry(4,4,4);

		var crateTexture = new THREE.TextureLoader( 'img/muro.jpg' );
		var cubeMat = new THREE.MeshBasicMaterial( { 
			map: crateTexture 
		});
		cubo = new THREE.Mesh(geometriaCubo, cubeMat);

		
		
		// el cubo emite sombra
		//cubo.castShadow = true;
		//cubo.receiveShadow = false;
		
		
		
		cubo.position.x = -4;
		cubo.position.y = 3;
		cubo.position.z = 0;
		
		targetList.push(cubo);
		
		
		escena.add(cubo);
		
		camara.position.x=-30;
		camara.position.y=40;
		camara.position.z=30;
		camara.lookAt(escena.position);
		
		var spotLight = new THREE.SpotLight(0xffffff);
		spotLight.position.set(0,250,0);
		spotLight.shadowCameraNear = true;
		
		escena.add(spotLight);
		
		$("#WebGL-salida").append(renderer.domElement);
		
		renderer.render(escena,camara);
		
		
	});
	
	function onDocumentMouseDown(event){	
				
		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		projector = new THREE.Projector();
		// find intersections

		// create a Ray with origin at the mouse position
		//   and direction into the scene (camera direction)
		var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
		projector.unprojectVector( vector, camara );
		var ray = new THREE.Raycaster( camara.position, vector.sub( camara.position ).normalize() );

		// create an array containing all objects in the scene with which the ray intersects
		var intersects = ray.intersectObjects( targetList );
		console.log(intersects);
		// if there is one (or more) intersections
		if ( intersects.length > 0 )
		{
			console.log("Hit @ " + toString( intersects[0].point ) );
			// change the color of the closest face.
			var crateTexture = new THREE.ImageUtils.loadTexture( 'img/muro.jpg' );
			var cubeMat = new THREE.MeshBasicMaterial( { 
				map: crateTexture 
			});
			intersects[0].object.material = cubeMat;
			//intersects[ 0 ].face.color.setRGB( 0.8 * Math.random() + 0.2, 0, 0 ); 
			intersects[ 0 ].object.geometry.colorsNeedUpdate = true;
			render();
		}
	}

	function toString(v) { return "[ " + v.x + ", " + v.y + ", " + v.z + " ]"; }

	function render() 
	{
		renderer.render( escena, camara );
	}


	</script>
	
</body>
</html>